---
title: "poisson_rescale_sim"
format: html
editor: visual
---

```{r setup, include=FALSE, warnings=FALSE, message=FALSE}

required_pkgs <- c("glmmTMB", "dplyr", "tibble", "purrr", "ggplot2", "broom.mixed", "parallel")
to_install <- required_pkgs[!(required_pkgs %in% installed.packages()[, "Package"])]
if(length(to_install)) {
  install.packages(to_install, repos = "https://cloud.r-project.org")
}

library(glmmTMB)
library(dplyr)
library(tibble)
library(purrr)
library(ggplot2)
library(broom.mixed)
library(parallel)

set.seed(2025)

# storage for results
results <- list()

# helper to safely fit glmmTMB and return NA on failure
safe_glmmTMB <- function(formula, data, family) {
  tryCatch({
    glmmTMB::glmmTMB(formula = formula, data = data, family = family)
  }, error = function(e) {
    warning("glmmTMB fit failed: ", conditionMessage(e))
    NULL
  })
}
```
## Introduction

This simulation explores how modelling Poisson distributed data on the beta scale changes the outcomes of the inference.

## Methods

The simulation uses three true-mean (λ) scenarios: 10, 100, 1000.

For each λ and for each observation count n in {10,100,1000} it runs nsims = 1000 simulations.

Each simulation draws n Poisson counts with mean λ.

Fits an intercept-only glmmTMB Poisson model (counts \~ 1, family = poisson(link="log")) and records the model-implied mean and variance.

Scales the raw counts by dividing by the observed maximum (so the maximum becomes 1), truncates any exact 1 to 1 - eps (so everything is in (0,1)), fits a glmmTMB Beta model (beta_family(link="logit")) to the scaled data, and converts the Beta-model estimates back to the original count scale (mean and variance) for comparison to the original Poisson-generated mean & variance.

Aggregates bias and RMSE for mean & variance across the 1000 sims for each combination and model.

### parameters

```{r}
#| label: params

lambdas <- c(10, 100, 1000)      # "sampling effort scenarios" interpreted as true Poisson means
ns <- c(10, 100, 1000)           # numbers of observations per simulated dataset
nsims <- 1000
eps_trunc <- 1e-6                # to move any exact 1.0 to 1 - eps for beta
```


### loop over combos

```{r}
#| label: runsims
#| cache: true
#| warning: false
#| echo: false
rowidx <- 1
for(lambda in lambdas) {
  for(n_obs in ns) {

    # containers for metrics across sims
    poiss_mean_est <- numeric(nsims)
    poiss_var_est  <- numeric(nsims)
    poiss_mean_true <- numeric(nsims)
    poiss_var_true  <- numeric(nsims)

    beta_mean_est_back <- numeric(nsims)
    beta_var_est_back  <- numeric(nsims)
    beta_mean_true <- numeric(nsims)
    beta_var_true  <- numeric(nsims)

    for(sim in 1:nsims) {
      # simulate Poisson data
      y <- rpois(n_obs, lambda = lambda)

      # true sample moments (these are the "observed" true mean/var for this dataset)
      mean_y <- mean(y)
      var_y  <- var(y)  # sample variance

      # store true (we'll compare model outputs back to these)
      poiss_mean_true[sim] <- mean_y
      poiss_var_true[sim]  <- var_y
      beta_mean_true[sim]  <- mean_y
      beta_var_true[sim]   <- var_y

      # -----------------------
      # Fit Poisson (glmmTMB) - intercept only
      # -----------------------
      dat_p <- data.frame(y = y)
      m_p <- safe_glmmTMB(y ~ 1, data = dat_p, family = poisson(link = "log"))
      if(!is.null(m_p)) {
        # intercept (log scale)
        intercept <- as.numeric(fixef(m_p)$cond[1])
        mu_hat <- exp(intercept)            # fitted mean on original count scale
        # For a Poisson model the model-implied variance = mean (no overdispersion parameter)
        var_hat <- mu_hat

        poiss_mean_est[sim] <- mu_hat
        poiss_var_est[sim]  <- var_hat
      } else {
        poiss_mean_est[sim] <- NA
        poiss_var_est[sim]  <- NA
      }

      # -----------------------
      # Prepare data for Beta model
      # -----------------------
      max_y <- max(y)
      if(max_y == 0) {
        # unlikely for lambda >= 10, but guard against it:
        # if everything is zero, set scaled values to very small positive values
        y_scaled <- rep(eps_trunc, length(y))
        max_y_for_backtransform <- 1 # to avoid dividing by zero - but this will make backtransform trivial
      } else {
        y_scaled <- y / max_y
        # truncate exact 1s to slightly less than 1 so Beta model is valid
        y_scaled[y_scaled >= 1] <- 1 - eps_trunc
        max_y_for_backtransform <- max_y
      }

      dat_b <- data.frame(y_scaled = y_scaled)

      # Fit Beta model (intercept-only) with logit link
      # glmmTMB has beta_family() for Beta regression
      m_b <- safe_glmmTMB(y_scaled ~ 1, data = dat_b, family = betabinomial()) # placeholder
      # NOTE: use correct beta_family in glmmTMB:
      # in many glmmTMB versions it is 'beta_family(link = "logit")'
      # but to be robust, try that:
      if(!is.null(m_b)) {
        # if the placeholder betabinomial used (unlikely), m_b may be something else.
        # We'll re-fit correctly below (try-catch)
        m_b <- NULL
      }
      if(is.null(m_b)) {
        m_b <- tryCatch({
          glmmTMB::glmmTMB(y_scaled ~ 1, data = dat_b, family = glmmTMB::beta_family(link = "logit"))
        }, error = function(e) {
          # try alternate constructor (older versions might use "beta_family" in a different way)
          tryCatch({
            glmmTMB::glmmTMB(y_scaled ~ 1, data = dat_b, family = stats::quasi(link = "logit"))
          }, error = function(e2) {
            warning("Beta-model fit failed (both attempts).")
            NULL
          })
        })
      }

      if(!is.null(m_b)) {
        # extract intercept for mu on logit scale
        intercept_b <- as.numeric(fixef(m_b)$cond[1])
        mu_scaled_hat <- plogis(intercept_b)  # estimated mean on scaled (0,1) scale

        # extract precision phi (phi>0). In glmmTMB the dispersion/precision fixed effect is in fixef(... )$disp
        phi_hat <- NA
        try({
          if(!is.null(fixef(m_b)$disp)) {
            # usually the dispersion/precision is modeled on log scale, so extract and exponentiate
            disp_coef <- as.numeric(fixef(m_b)$disp[1])
            phi_hat <- exp(disp_coef)
          } else {
            # alternative extraction via summary
            s <- summary(m_b)
            if("disp" %in% names(s$coefficients)) {
              disp_coef <- as.numeric(s$coefficients$disp[ , "Estimate"][1])
              phi_hat <- exp(disp_coef)
            }
          }
        }, silent = TRUE)

        # If phi not found, attempt to extract from sigma() or fit$par
        if(is.na(phi_hat)) {
          # try reading from m_b$fit$par ; parameter names vary between versions - try heuristics
          try({
            pnames <- names(m_b$fit$par)
            # many times the dispersion is stored in "theta" or "phi", try matching
            idx <- grep("phi|theta|disp", pnames, ignore.case = TRUE)
            if(length(idx) > 0) {
              phi_hat <- exp(m_b$fit$par[idx[1]])
            }
          }, silent = TRUE)
        }

        if(is.na(phi_hat)) {
          # fallback: if cannot extract, set phi_hat = large number so beta var small (conservative)
          phi_hat <- NA
          warning("Could not extract beta precision (phi) from glmmTMB fit; will set NA for Beta variance.")
        }

        # Beta variance formula for (mu, phi): Var(Y) = mu*(1-mu)/(1+phi)
        if(!is.na(phi_hat)) {
          var_scaled_hat <- mu_scaled_hat * (1 - mu_scaled_hat) / (1 + phi_hat)
        } else {
          var_scaled_hat <- NA
        }

        # back-transform to original count scale:
        mean_back <- mu_scaled_hat * max_y_for_backtransform
        var_back  <- if(!is.na(var_scaled_hat)) var_scaled_hat * (max_y_for_backtransform^2) else NA

        beta_mean_est_back[sim] <- mean_back
        beta_var_est_back[sim]  <- var_back
      } else {
        beta_mean_est_back[sim] <- NA
        beta_var_est_back[sim]  <- NA
      }
    } # end sims

    # compute summary metrics: bias and RMSE for mean & variance, for each model
    summarise_metrics <- function(est, truth) {
      ok <- !is.na(est) & !is.na(truth)
      est2 <- est[ok]; tr2 <- truth[ok]
      if(length(est2) == 0) return(list(n = 0, bias = NA, rmse = NA, sd_est = NA))
      bias <- mean(est2 - tr2)
      rmse <- sqrt(mean((est2 - tr2)^2))
      list(n = length(est2), bias = bias, rmse = rmse, sd_est = sd(est2))
    }

    # Poisson model metrics (mean)
    pm_mean <- summarise_metrics(poiss_mean_est, poiss_mean_true)
    pm_var  <- summarise_metrics(poiss_var_est, poiss_var_true)

    # Beta-backtransformed metrics
    bm_mean <- summarise_metrics(beta_mean_est_back, beta_mean_true)
    bm_var  <- summarise_metrics(beta_var_est_back, beta_var_true)

    # collect results in a data.frame row
    row <- tibble::tibble(
      lambda = lambda,
      n_obs  = n_obs,
      model = c("poisson_glmmTMB", "beta_glmmTMB_backtrans"),
      metric = rep(c("mean", "variance"), each = 1),
      bias = c(pm_mean$bias, bm_mean$bias),
      rmse = c(pm_mean$rmse, bm_mean$rmse),
      n_success = c(pm_mean$n, bm_mean$n)
    )

    # for variance (append second row for variance)
    row2 <- tibble::tibble(
      lambda = lambda,
      n_obs  = n_obs,
      model = c("poisson_glmmTMB", "beta_glmmTMB_backtrans"),
      metric = rep(c("mean", "variance"), each = 1),
      bias = c(pm_var$bias, bm_var$bias),
      rmse = c(pm_var$rmse, bm_var$rmse),
      n_success = c(pm_var$n, bm_var$n)
    )

    # combine (structure to give 4 rows: Poisson-mean, Beta-mean, Poisson-var, Beta-var)
    # we'll store as a list element for later rbind
    results[[paste0("lam", lambda, "_n", n_obs)]] <- dplyr::bind_rows(
      tibble(lambda=lambda,n_obs=n_obs, model="poisson_glmmTMB", metric="mean",
             bias=pm_mean$bias, rmse=pm_mean$rmse, n_success=pm_mean$n),
      tibble(lambda=lambda,n_obs=n_obs, model="beta_glmmTMB_backtrans", metric="mean",
             bias=bm_mean$bias, rmse=bm_mean$rmse, n_success=bm_mean$n),
      tibble(lambda=lambda,n_obs=n_obs, model="poisson_glmmTMB", metric="variance",
             bias=pm_var$bias, rmse=pm_var$rmse, n_success=pm_var$n),
      tibble(lambda=lambda,n_obs=n_obs, model="beta_glmmTMB_backtrans", metric="variance",
             bias=bm_var$bias, rmse=bm_var$rmse, n_success=bm_var$n)
    )

    cat("Done lambda=", lambda, " n=", n_obs, "\n")
  }
}
```

## Results

```{r}
#| label: results
final_res <- dplyr::bind_rows(results)

# present results
final_res %>% arrange(lambda, n_obs, model, metric) %>% print(n = Inf)
```


