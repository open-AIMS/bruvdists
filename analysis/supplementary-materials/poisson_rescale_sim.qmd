---
title: "poisson_rescale_sim"
format: html
editor: visual
---

```{r setup, include=FALSE, warnings=FALSE, message=FALSE}

required_pkgs <- c("glmmTMB", "dplyr", "tibble", "purrr", "ggplot2", "broom.mixed", "parallel")
to_install <- required_pkgs[!(required_pkgs %in% installed.packages()[, "Package"])]
if(length(to_install)) {
  install.packages(to_install, repos = "https://cloud.r-project.org")
}
library(bruvdists)
library(glmmTMB)
library(dplyr)
library(tibble)
library(purrr)
library(ggplot2)
library(broom.mixed)
library(future)
library(future.apply)

set.seed(2025)

# parallel settings
available_cores <- parallel::detectCores(logical = FALSE)
# Use all but 1 core if possible, but at least 1
mc_cores_want <- max(1, available_cores - 1)
if(.Platform$OS.type == "windows") {
  message("Windows detected: mclapply is not available; falling back to sequential lapply.")
  mc_cores <- 1
} else {
  mc_cores <- mc_cores_want
  message("Using mc.cores = ", mc_cores)
}

```
## Introduction

This simulation explores how modelling Poisson distributed data on the beta scale changes the outcomes of the inference.

## Methods

The simulation uses three true-mean (λ) scenarios: 10, 100, 1000.

For each λ and for each observation count n in {10,100,1000} it runs nsims = 1000 simulations.

Each simulation draws n Poisson counts with mean λ.

Fits an intercept-only glmmTMB Poisson model (counts \~ 1, family = poisson(link="log")) and records the model-implied mean and variance.

Scales the raw counts by dividing by the observed maximum (so the maximum becomes 1), truncates any exact 1 to 1 - eps (so everything is in (0,1)), fits a glmmTMB Beta model (beta_family(link="logit")) to the scaled data, and converts the Beta-model estimates back to the original count scale (mean and variance) for comparison to the original Poisson-generated mean & variance.

Aggregates bias and RMSE for mean & variance across the 1000 sims for each combination and model.

### Parameters

```{r}
#| label: params

lambdas <- c(10, 100, 1000)      # "sampling effort scenarios" interpreted as true Poisson means
ns <- c(10, 100, 1000)           # numbers of observations per simulated dataset
nsims <- 1000
eps_trunc <- 1e-6                # to move any exact 1.0 to 1 - eps for beta
```


### Run sims

```{r}
#| label: runsims
#| cache: true
#| warning: false
#| echo: false

if (mc_cores > 1) {
  plan(multisession, workers = mc_cores)  # portable parallelism
  # If you're on Linux/macOS and prefer forked processes:
  # plan(multicore, workers = mc_cores)
} else {
  plan(sequential)
}
all_results <- list()
progress_total <- length(lambdas) * length(ns)
progress_counter <- 0

for (lambda in lambdas) {
  for (n_obs in ns) {
    progress_counter <- progress_counter + 1
    message(sprintf("Starting lambda = %g, n_obs = %d   (%d/%d)",
                    lambda, n_obs, progress_counter, progress_total))
    
    sim_indices <- seq_len(nsims)
    
    ## --- Option A: future_lapply (recommended drop-in for mclapply) ---
    sims_out <- future_lapply(
      sim_indices,
      function(i) run_one_sim(i, lambda = lambda, n_obs = n_obs),
      future.seed = TRUE   # reproducible RNG streams
    )
    
    ## --- Option B: strictly future_apply over rows (MARGIN = 1) ---
    # sims_out <- future_apply(
    #   matrix(sim_indices),  # one-column matrix of indices
    #   MARGIN = 1,
    #   FUN = function(i) run_one_sim(i, lambda = lambda, n_obs = n_obs),
    #   future.seed = TRUE
    # )
    
    # Convert list of named lists to tibble
    df <- purrr::map_dfr(sims_out, ~ as_tibble(.x))
    
    # Add metadata
    df <- df %>%
      mutate(lambda = lambda, n_obs = n_obs, sim = seq_len(n()))
    
    all_results[[paste0("lam", lambda, "_n", n_obs)]] <- df
    message(sprintf("Finished lambda=%g, n=%d  (rows=%d)", lambda, n_obs, nrow(df)))
  }
}

# Optional: return to sequential when done
plan(sequential)

sim_df <- bind_rows(all_results, .id = "scenario")

```

## Results

```{r}
#| label: results
summary_rows <- list()

for(lambda in lambdas) {
  for(n_obs in ns) {
    sub <- sim_df %>% filter(lambda == lambda, n_obs == n_obs)

    # Poisson mean
    s_pm_mean <- summarise_bias_rmse(sub$mu_p_hat, sub$mean_true) %>% mutate(model = "poisson", metric = "mean")
    s_pm_var  <- summarise_bias_rmse(sub$var_p_hat, sub$var_true)  %>% mutate(model = "poisson", metric = "variance")

    # Negative binomial
    s_nb_mean <- summarise_bias_rmse(sub$mu_nb_hat, sub$mean_true) %>% mutate(model = "nbinom2", metric = "mean")
    s_nb_var  <- summarise_bias_rmse(sub$var_nb_hat, sub$var_true)  %>% mutate(model = "nbinom2", metric = "variance")

    # Beta backtransformed
    s_b_mean  <- summarise_bias_rmse(sub$mu_b_back, sub$mean_true) %>% mutate(model = "beta_back", metric = "mean")
    s_b_var   <- summarise_bias_rmse(sub$var_b_back, sub$var_true)  %>% mutate(model = "beta_back", metric = "variance")

    block <- bind_rows(
      s_pm_mean, s_b_mean, s_nb_mean,
      s_pm_var,  s_b_var,  s_nb_var
    ) %>%
      mutate(lambda = lambda, n_obs = n_obs) %>%
      select(lambda, n_obs, model, metric, everything())

    summary_rows[[paste0("lam", lambda, "_n", n_obs)]] <- block
  }
}

summary_df <- bind_rows(summary_rows)

# reorder factors for plotting
summary_df <- summary_df %>%
  mutate(model = factor(model, levels = c("poisson", "nbinom2", "beta_back")),
         metric = factor(metric, levels = c("mean", "variance")))

# print summary table
print(summary_df)
```

### Bias plot

```{r}
#| label: plots

p_bias <- ggplot(summary_df, aes(x = factor(n_obs), y = bias, color = model, group = model)) +
  geom_point(size = 3) +
  geom_line() +
  facet_wrap(~ metric + lambda, scales = "free_y", ncol = length(lambdas)) +
  labs(title = "Bias of model estimates (mean and variance)",
       x = "Number of observations (n)",
       y = "Bias (estimate - observed sample moment)") +
  theme_minimal()

print(p_bias)

# RMSE plot
p_rmse <- ggplot(summary_df, aes(x = factor(n_obs), y = rmse, color = model, group = model)) +
  geom_point(size = 3) +
  geom_line() +
  facet_wrap(~ metric + lambda, scales = "free_y", ncol = length(lambdas)) +
  labs(title = "RMSE of model estimates (mean and variance)",
       x = "Number of observations (n)",
       y = "RMSE (root mean squared error)") +
  theme_minimal()

print(p_rmse)
```


